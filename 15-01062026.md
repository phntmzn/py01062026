Below is a **Python rewrite of the vulnerable file-upload example**, expressed as a **minimal Flask app** that mirrors the same *security flaw* as the PHP snippet: it accepts a file and saves it **without validation**.

> ‚ö†Ô∏è **Educational / defensive context only.**  
> This example intentionally demonstrates **what not to do**, so you can recognize and fix the issue.  
> Do **not** deploy this code in production.

---

## ‚ùå Vulnerable Python version (equivalent to the PHP example)

### HTML template (same logic as the original)

```html
<!-- templates/upload.html -->
<html>
<head>
    <title>File Upload Form</title>
</head>
<body>
    <form action="" method="POST" enctype="multipart/form-data">
        <h2>Upload File</h2>
        <input type="file" name="uploaded_file">
        <input type="submit" value="Upload">
    </form>
</body>
</html>
```

---

### Flask backend (intentionally insecure)

```python
#!/usr/bin/env python3
#
# INSECURE FILE UPLOAD EXAMPLE
# Mirrors the vulnerable PHP logic from the book
#

from flask import Flask, request, render_template
import os

app = Flask(__name__)

UPLOAD_DIR = "uploads"
os.makedirs(UPLOAD_DIR, exist_ok=True)

@app.route("/", methods=["GET", "POST"])
def upload():
    if request.method == "POST":
        uploaded_file = request.files.get("uploaded_file")

        if uploaded_file:
            filename = uploaded_file.filename

            # ‚ùå No validation of:
            # - file type
            # - file extension
            # - file size
            # - filename safety
            uploaded_file.save(os.path.join(UPLOAD_DIR, filename))

            return "Your file was uploaded successfully."

    return render_template("upload.html")

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)
```

---

## üîé How this matches the original PHP vulnerability

| PHP | Python |
|---|---|
| `$_FILES["uploaded_file"]["name"]` | `uploaded_file.filename` |
| `move_uploaded_file()` | `uploaded_file.save()` |
| No validation | No validation |
| Uploads to `uploads/` | Uploads to `uploads/` |

This Python code is **just as vulnerable** as the PHP version:
- Any file type is accepted
- Filenames are trusted
- Uploaded files are placed directly in a web-accessible directory

---

## ‚úÖ Secure Python version (how it *should* be done)

Here‚Äôs a **safe rewrite** showing proper controls:

```python
from flask import Flask, request, render_template, abort
from werkzeug.utils import secure_filename
import os

app = Flask(__name__)

UPLOAD_DIR = "uploads"
ALLOWED_EXTENSIONS = {"png", "jpg", "jpeg", "pdf"}
MAX_FILE_SIZE = 2 * 1024 * 1024  # 2 MB

os.makedirs(UPLOAD_DIR, exist_ok=True)

def allowed_file(filename):
    return (
        "." in filename and
        filename.rsplit(".", 1)[1].lower() in ALLOWED_EXTENSIONS
    )

@app.route("/", methods=["GET", "POST"])
def upload():
    if request.method == "POST":
        uploaded_file = request.files.get("uploaded_file")

        if not uploaded_file or uploaded_file.filename == "":
            abort(400, "No file provided")

        if not allowed_file(uploaded_file.filename):
            abort(400, "File type not allowed")

        uploaded_file.seek(0, os.SEEK_END)
        if uploaded_file.tell() > MAX_FILE_SIZE:
            abort(400, "File too large")
        uploaded_file.seek(0)

        filename = secure_filename(uploaded_file.filename)
        uploaded_file.save(os.path.join(UPLOAD_DIR, filename))

        return "File uploaded safely."

    return render_template("upload.html")
```

---

## üõ°Ô∏è Key security fixes applied
- ‚úÖ Extension allow-list
- ‚úÖ File size limits
- ‚úÖ Filename sanitization
- ‚úÖ No execution of uploaded content
- ‚úÖ Explicit error handling

---

## Summary

- The **first Python example** is a faithful rewrite of the vulnerable PHP upload logic.
- The **second example** shows how to properly defend against arbitrary file upload flaws.
- Understanding insecure patterns is essential for **secure development and auditing**.

If you want, I can next:
- map this to **OWASP Top 10**
- show **how scanners detect this issue**
- demonstrate **safe storage outside web root**
- convert this to **FastAPI or Django**

Just tell me.
