Below is a **Python rewrite** of the concepts in your excerpt.  
It collects **current login sessions and historical user activity** by safely invoking standard Linux tools and handling errors so it **fails gracefully** on systems where files or commands aren’t available.

This mirrors what `w`, `who`, `last`, and `lastb` do, but wrapped in Python.

---

## What the script does

1. Detects whether it’s running on Linux  
2. Collects:
   - Current logged-in users (`w`)
   - Current sessions (`who`)
   - Historical logins (`last`)
   - Failed login attempts (`lastb`, if permitted)
3. Handles missing permissions or commands cleanly
4. Exits with meaningful status codes

---

## Exit codes

| Code | Meaning |
|----|--------|
| `0` | Data collected successfully |
| `1` | Partial data collected (some commands unavailable) |
| `2` | Not a Linux system |
| `3` | Unexpected error |

---

## `user_sessions.py`

```python
#!/usr/bin/env python3
"""
User session and login activity collection (Linux)

Wraps standard commands:
- w
- who
- last
- lastb (optional, requires elevated privileges)

Fails gracefully if files or commands are unavailable.
"""

import subprocess
import sys

def run_command(cmd):
    try:
        result = subprocess.run(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            timeout=3
        )
        if result.returncode == 0:
            return result.stdout.strip()
        return None
    except (FileNotFoundError, subprocess.TimeoutExpired):
        return None

def main():
    try:
        # 1) Ensure Linux
        if sys.platform != "linux":
            print("This script is intended for Linux systems.")
            sys.exit(2)

        partial = False

        print("=== Current Logged-In Users (w) ===")
        output = run_command(["w"])
        if output:
            print(output)
        else:
            print("Unavailable")
            partial = True

        print("\n=== Current Sessions (who) ===")
        output = run_command(["who"])
        if output:
            print(output)
        else:
            print("Unavailable")
            partial = True

        print("\n=== Login History (last) ===")
        output = run_command(["last", "-n", "10"])
        if output:
            print(output)
        else:
            print("Unavailable")
            partial = True

        print("\n=== Failed Login Attempts (lastb) ===")
        output = run_command(["lastb", "-n", "10"])
        if output:
            print(output)
        else:
            print("Unavailable (may require root privileges)")
            partial = True

        if partial:
            sys.exit(1)
        sys.exit(0)

    except Exception as e:
        print(f"Unexpected error: {e}")
        sys.exit(3)

if __name__ == "__main__":
    main()
```

---

## Example output (typical)

```
=== Current Logged-In Users (w) ===
 15:02:41 up 10 days,  3 users,  load average: 0.01, 0.03, 0.00
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
backup   pts/0    172.16.10.13     14:48    2:00   0.02s  0.01s bash

=== Current Sessions (who) ===
backup   pts/0        2026-01-06 14:48 (172.16.10.13)

=== Login History (last) ===
backup   pts/0        172.16.10.13  Tue Jan  6 14:48   still logged in

=== Failed Login Attempts (lastb) ===
Unavailable (may require root privileges)
```

---

## How this maps to the excerpt

| Bash command | Python equivalent |
|-------------|------------------|
| `w` | `subprocess.run(["w"])` |
| `who` | `subprocess.run(["who"])` |
| `last` | `subprocess.run(["last"])` |
| `lastb` | `subprocess.run(["lastb"])` |
| `/var/run/utmp` | Parsed indirectly via commands |
| `/var/log/wtmp` | Parsed indirectly via `last` |

---

## Why this approach is solid

- Uses **trusted system tools** instead of parsing binary utmp/wtmp files manually
- Handles permission issues cleanly
- Works on most Linux distributions
- Suitable for automation and auditing
- Matches real-world administrative workflows

---

## Optional extensions (if you want)

- Parse output into structured Python objects
- Detect source IP reuse (jump hosts)
- Export to JSON or CSV
- Add alerting for unusual login patterns
- Implement direct utmp/wtmp parsing for deeper analysis

Tell me how far you want to take it.
