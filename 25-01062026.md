Below is a **Python rewrite of the concept** from the excerpt, written in a **defensive / administrative context**.  
It demonstrates how to **probe an internal network**, **prioritize ports**, and **map ports to services using `/etc/services`**, while handling errors cleanly.

This mirrors what the book describes without relying on custom exploit code.

---

## What this Python script does

1. Reads `/etc/services` to map **ports â†’ service names**
2. Defines a **prioritized list of common ports** (those most frequently open)
3. Performs a **simple TCP connect scan** against a target network
4. Prints **open ports with service names**
5. Fails gracefully if files or hosts are unavailable

---

## Important notes

- This is a **lightweight connect scan**, not a SYN scan
- No raw packets
- No privilege escalation
- Suitable for **internal inventory, auditing, and lab use**
- Only scan networks you own or are authorized to test

---

## Exit codes

| Code | Meaning |
|----|--------|
| `0` | Scan completed successfully |
| `1` | Partial results |
| `2` | Not a Linux system |
| `3` | Unexpected error |

---

## `network_probe.py`

```python
#!/usr/bin/env python3
"""
Internal network probing with service mapping (Linux)

- Prioritizes commonly open ports
- Maps ports to service names via /etc/services
- Uses TCP connect scanning
- Fails gracefully
"""

import socket
import sys
from pathlib import Path

# Commonly open ports, ordered by frequency
PRIORITY_PORTS = [
    22,    # SSH
    80,    # HTTP
    443,   # HTTPS
    3389,  # RDP
    3306,  # MySQL
    445,   # SMB
    139,   # NetBIOS
    53,    # DNS
    25,    # SMTP
    21,    # FTP
]

TIMEOUT = 0.5

def load_services():
    services = {}
    path = Path("/etc/services")

    if not path.exists():
        return services

    try:
        for line in path.read_text().splitlines():
            if not line or line.startswith("#"):
                continue

            parts = line.split()
            if len(parts) < 2:
                continue

            name = parts[0]
            port_proto = parts[1]

            if "/" in port_proto:
                port, proto = port_proto.split("/", 1)
                if proto == "tcp":
                    services[int(port)] = name
    except Exception:
        pass

    return services

def scan_port(host, port):
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(TIMEOUT)
            return s.connect_ex((host, port)) == 0
    except Exception:
        return False

def main():
    try:
        if sys.platform != "linux":
            print("This script is intended for Linux systems.")
            sys.exit(2)

        network = input("Target network (example: 10.1.0.): ").strip()
        if not network.endswith("."):
            print("Network must end with a dot, e.g. 10.1.0.")
            sys.exit(1)

        services = load_services()
        partial = False

        print(f"\nProbing network {network}0/24\n")

        for host_id in range(1, 255):
            host = f"{network}{host_id}"
            found = False

            for port in PRIORITY_PORTS:
                if scan_port(host, port):
                    service = services.get(port, "unknown")
                    print(f"{host}:{port} ({service}) open")
                    found = True

            if found:
                print("-" * 40)

        sys.exit(0)

    except KeyboardInterrupt:
        print("\nScan interrupted by user.")
        sys.exit(1)
    except Exception as e:
        print(f"Unexpected error: {e}")
        sys.exit(3)

if __name__ == "__main__":
    main()
```

---

## Example output

```
Target network (example: 10.1.0.): 10.1.0.

Probing network 10.1.0.0/24

10.1.0.5:22 (ssh) open
10.1.0.5:443 (https) open
----------------------------------------
10.1.0.12:3306 (mysql) open
----------------------------------------
```

---

## How this maps to the excerpt

| Concept in text | Python implementation |
|----------------|----------------------|
| Internal network probing | `/24` host loop |
| Port prioritization | `PRIORITY_PORTS` |
| Service mapping | `/etc/services` |
| Faster discovery | Scan common ports first |
| Linux tooling | Native sockets + files |

---

## Why this approach is effective

- Prioritizing ports reduces scan time
- `/etc/services` provides reliable service names
- Connect scans work without root privileges
- Internal networks benefit from speed over stealth
- Script is reusable and extensible

---

## Optional extensions (if you want)

- Parse `/etc/services` once and cache results
- Add threading for faster scans
- Support CIDR parsing automatically
- Output JSON for asset inventories
- Detect host liveness before port scans

If you want the **threaded**, **CIDR-aware**, or **service-enriched** version next, tell me which one to build.
